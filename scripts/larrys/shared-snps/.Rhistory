row.names=c('g','f','fg','e','d','de','c','b','bc','bcde','a','abcde','all','out'))
# extract counts needed for legend:
#leg.counts <- c(      61, 41,207, 61, 30, 1005,   18, 19) #by hand, medium chr1
leg.counts <- lmed[c('a','b','c','d','e','bcde','bc','de'),1]
discord <- total.snps - sum(lmed$lengths)
#tree.labels <- list( ## x,y,text; coords are all picked by eye
#   3000, 3.62, paste(lmed['all'  ,1], 'shared by 7', sep='\n'), # 7054
#   8900, 5.75, paste(lmed['abcde',1], 'by 5'       , sep='\n'), # 3912
#  12000, 1.50, paste(lmed['fg'   ,1], 'shared by 2', sep='\n'), # 9365
#  21000, 2.00, paste(lmed['f'    ,1], 'only\nin Wales'),        # 9652
#  21000, 1.00, paste(lmed['g'    ,1], 'only\nin Italy'),        # 8813
#  11500, 4.50, '*')
# automating x-placement, below; retain above for comparison...
tip <- integer(7)  # x coords of tree tips
tip[1] <-sum(lmed[c('all','fg','g'),1])
tip[2] <-sum(lmed[c('all','fg','f'),1])
tip[3] <-sum(lmed[c('all','abcde','bcde','de','e'),1])
tip[4] <-sum(lmed[c('all','abcde','bcde','de','d'),1])
tip[5] <-sum(lmed[c('all','abcde','bcde','bc','c'),1])
tip[6] <-sum(lmed[c('all','abcde','bcde','bc','b'),1])
tip[7] <-sum(lmed[c('all','abcde','a'),1])
inode <- integer(5) # x coords of (some) internal nodes
inode[1] <- 0                                    # root
inode[2] <- lmed['all',1]                        # lca of all
inode[3] <- sum(lmed[c('all','fg'),1])           # lca H-clade
inode[4] <- sum(lmed[c('all','abcde'),1])        # lca L-clade
inode[5] <- sum(lmed[c('all','abcde','bcde'),1]) # lca L-clade, nonGyre
tree.labels <- list( ## x,y,text; y coords partially picked by eye
sum(inode[c(1,2)])/2, 3.62, paste(lmed['all'  ,1], 'shared by 7', sep='\n'), # 7054
sum(inode[c(2,4)])/2, 5.75, paste(lmed['abcde',1], 'by 5'       , sep='\n'), # 3912
sum(inode[c(2,3)])/2, 1.50, paste(lmed['fg'   ,1], 'shared by 2', sep='\n'), # 9365
(inode[3]+tip[2])/2,  2.00, paste(lmed['f'    ,1], 'only\nin 1013'),         # 9652
(inode[3]+tip[1])/2,  1.00, paste(lmed['g'    ,1], 'only\nin 3367'),         # 8813
sum(inode[c(4,5)])/2, 4.35, '* ')
tree.labels <- list( ## x,y,text; y coords partially picked by eye
sum(inode[c(1,2)])/2, 3.62, paste(lmed['all'  ,1], 'in 7', sep='\n'), # 7054
sum(inode[c(2,4)])/2, 5.75, paste(lmed['abcde',1], 'in 5', sep='\n'), # 3912
sum(inode[c(2,3)])/2, 1.50, paste(lmed['fg'   ,1], 'in 2', sep='\n'), # 9365
(inode[3]+tip[2])/2,  2.00, paste(lmed['f'    ,1], 'only\nin 1013'),  # 9652
(inode[3]+tip[1])/2,  1.00, paste(lmed['g'    ,1], 'only\nin 3367'),  # 8813
sum(inode[c(4,5)])/2, 4.35, '* ')
####
#
# BOGUS PLOT
#
# a messy bit: need string widths to set xlim; but strwidth needs x-scale so must plot first.
# M plot completely invisible, overlay 2nd plot via par(new=F...) .
#
# PROVISIONALLY set x.lim here at about 30% wider than tree; fine tune it for the real plot
# based on strwidth(tip labels) below.
#
provisional.tree.x.lim <- 1.3 * max(tip) # <== PROVISIONAL plot width
plot(0,0, type='n', bty='n', xaxt='n', yaxt='n', xlab='', ylab='', xlim=c(0,provisional.tree.x.lim), ylim=c(0,7))
tiplabel.x <- integer(7)
for(i in 1:7){
# see warning above about internals of the.tree; labels have '_', printed as ' '.
tiplabel.x[i] <- tip[i]+strwidth(gsub('_',' ',the.tree$tip.label[i],fixed=T), font=font.tip)
}
# visually show tip coords & max x to debug placement issues
plt.debug <- function(tree.x.lim, tip, tiplabel.x, spx=NULL, spy=NULL){
if(pltdebug){ # F to hide/T to show debug
cat('Tip labels:', paste(the.tree$tip.label,sep='',collapse='/'), '\n')
axis(2) # useful only for placing labels
for(i in 1:7){
points(c(tip[i],tiplabel.x[i]),c(i,i)) # debug: do I have right tip coordinates?
}
lines(rep(tree.x.lim,2),c(0,7)) # where is right edge?
if(!is.null(spx)){
points(spx,spy) # show spline control points, for tweaking
}
}
}
plt.debug(provisional.tree.x.lim, tip, tiplabel.x)
label.end.H <- max(tiplabel.x[1:2])
label.end.L <- max(tiplabel.x[3:7])
clade.dx <- strwidth('x') # space between clade marker line and its label
xdel <- 3*clade.dx        # space between labeled clade tips and marker line
tree.x.lim <- 1.03*(max(tiplabel.x)+xdel)  # <== FINAL plot width
tree.y.lim <- 7
if(pltdebug){cat('Plot width hacking:', provisional.tree.x.lim, tree.x.lim, tree.x.lim/1.03/max(tip), clade.dx)}
par(new=T)  # I.e., NOT starting a new plot
####
#
# REAL PLOT
#
plot(the.tree,
x.lim = c(0, tree.x.lim),
y.lim = c(0, tree.y.lim),
font=font.tip, label.offset=100,             # bold-italic, nudged slightly right
tip.color=col.tip, edge.color=col.edge,
edge.width=lwd.edge,
edge.lty=c(1,1,1,1, 1 ,1,1,1,1,1,1,1,1,0)    # 5th is bottleneck edge; 14th is outgroup
)
lines(00+c(0,0),c(3.5,6),col='white',lwd=6)       # Hide vertical line to outgroup
axis(1, pos=0.25, at=seq(0,25,by=5)*10^round(log10(max(tip)/25)))
if(pltdebug){text(tip[1]+100, 1.0, 'Venice, Italy (3367)', adj=0, font=font.tip)}
####
#
# BOTTLENECK ANNOTATION
#
# spline/elipse control points (spy/y) & tweaks thereto (dx/y)
dx <- 0.01 * tree.x.lim
dy <- .04
spx <- c(7400, 7400, 9900, 10500) # by eye, chr1, for comparison
spx <- c(inode[2]+dx,inode[2]+dx,inode[4]-3*dx,inode[4]-dx)
spy <- c( 3.8,  3.9,  5.6-dy,   5.6-dy)
plt.debug(tree.x.lim, tip, tiplabel.x, spx, spy)
if(T){
#elipse version, defined by rect thru 2 middle pts of spx/y
spf<-function(x){
ifelse(x <= spx[2], spy[1],
ifelse(x >= spx[3], spy[4],
spy[2]+(spy[3]-spy[2])*sqrt(pmax(0,1-((x-spx[3])/(spx[3]-spx[2]))^2))))
}
} else {
# spline version
spf <- splinefun(spx,spy,method='hyman')
}
serx <- seq(spx[1],spx[length(spx)],length.out=50)
sery <- spf(serx)
tailx <- spx[1]
taily <- spy[1]
headx <- spx[4]
heady <- spy[4]
textx <- (headx+tailx)/2+(headx-tailx)*(-.01)
texty <- (heady+taily)/2+(heady-taily)*(-.10)
bottle.txt <- "inbreeding\nLoH / LoS"
if(!straight.arrow){
arrows(headx,heady,headx+tree.x.lim*1e-3,heady, length=.1,col=col.arrow,lwd=lwd.arrow)
lines(rev(serx), rev(sery), lty=c(5,1),col=col.arrow, lwd=lwd.arrow)
textangle <- 66
textadj <- c(0,0)
} else {
# Tweak positioning slightly; visualize a rectangle from 7-node to base of L-clade;
# center text, rotated, on diagonal towards L-clade; ditto the straight arrow.
llx <- inode[2] # the aforementioned rectangle
urx <- inode[4]
lly <- 3.62
ury <- 5.75
# rect(llx,lly,urx,ury) # show rect for debug
textx <- (llx+urx)/2    # center text
texty <- (lly+ury)/2
textangle <- atan(grconvertY(ury-lly,to='dev')/grconvertX(urx-llx,to='dev'))*360/(2*pi)
textadj <- c(0.50, 0.45)
alpha <- .78 # fraction along diag at which arrow begins
beta  <- .95 # ... and ends
arrows((1-alpha)*llx + alpha*urx,
(1-alpha)*lly + alpha*ury,
(1-beta)*llx  + beta*urx,
(1-beta)*lly  + beta*ury, length=.1,col=col.arrow,lwd=lwd.arrow,angle=25)
}
if(T){
text(textx, texty, bottle.txt, srt=textangle, font=font.arrow, cex=cex.arrow,
col=col.arrow, adj=textadj)
} else {
# experiment at wrapping text along curved path; unpretty, but retain for now, maybe revisit
bottlec <- strsplit(bottle,split=NULL)[[1]]
for(i in 1:length(bottlec)){
text(xser[i],yser[i],bottlec[i], srt=65, font=4, cex=.7, col=col.arrow)
}
}
####
#
# CLADE ANNOTATION
#
clade.L.x <- label.end.L + xdel
clade.H.x <- label.end.H + xdel
dy <-.33
lines(rep(clade.L.x,2),c(3-dy,7+dy),lwd=lwd.clade,col=col.clade)
lines(rep(clade.H.x,2),c(1-dy,2+dy),lwd=lwd.clade,col=col.clade)
text(clade.L.x+clade.dx,5.0,'L-clade',srt=90,font=font.clade,cex=cex.clade,col=col.clade)
text(clade.H.x+clade.dx,1.5,'H-clade',srt=90,font=font.clade,cex=cex.clade,col=col.clade)
####
#
# LEGEND
#
# parameter plusx controls whether we try to annotate b/c (+) and d/e (x) sharing in tree; I think
# it looks cluttered, rather than adding clarity, so I vote no, but code is here, in case.  "Logic,"
# if any, for my symbol choice is that + overlaid on x looks like the * at the next level; this
# analogy is more visible if we use pch 3/4/8 rather than Courier or Helvetica chars, but probably
# should use same in both tree & legend, which will take a modicum of additional work.
legend.text <- c('a: only in 1014  ',
'b: only in 1335  ',
'c: only in 1015  ',
'd: only in 1012  ',
'e: only in 1007  ',
'*: shared by bcde',
paste(ifelse(plusx,'+:','  '),'shared by b/c '),
paste(ifelse(plusx,'x:','  '),'shared by d/e ')
)
legend.text <- c('a: only in 1014 ',
'b: only in 1335 ',
'c: only in 1015 ',
'd: only in 1012 ',
'e: only in 1007 ',
'*: in bcde      ',
paste(ifelse(plusx,'+:','  '),'in bc        '),
paste(ifelse(plusx,'x:','  '),'in de        '),
'Discordant SNPs '
)
legend.text <- paste(legend.text,format(c(leg.counts,discord),width=4),sep=' - ')
legend.text <- paste(legend.text,' ') # add a little more right margin in box
opar <- par(family='mono',cex=cex.legend)
legend('topright', legend=legend.text, cex=cex.legend, inset=c(0.05,0), bg=col.legbox, box.col=col.legbox)
par(opar)
if(plusx){
points(tree.labels[[16]],tree.labels[[17]]+.14,pch=8,col=col.elabel)
points(tree.labels[[16]]+200,tree.labels[[17]]+1,pch=3,col=col.elabel)
points(tree.labels[[16]]+200,tree.labels[[17]]-1,pch=4,col=col.elabel)
}
####
#
# EDGE LENGTHS
#
for(i in seq(1,length(tree.labels)-ifelse(plusx,5,2),by=3)){
if(F){ # T for \n in edge labels; F to remove (except "by 5")
text(tree.labels[[i]], tree.labels[[i+1]], tree.labels[[i+2]])
} else {
# points(tree.labels[[i]], tree.labels[[i+1]], pch=3,col='green') # for debugging
text(tree.labels[[i]], tree.labels[[i+1]], sub('\n([^z])',' \\1', tree.labels[[i+2]]),
pos=3, offset=.4, font=font.elabel, col=col.elabel,cex=cex.elabel)
}
}
}
pdf(paperfig.path, width=8,height=5,onefile=TRUE,family='Helvetica',fonts='Courier',pointsize=10)
show.tree(newick.medium, total.snps=consistent.count[2], pltdebug=F,straight.arrow = T)
dev.off()
# run following 2 lines after an R upgrade
# update.packages()
# install.packages("ape")
library(ape)
show.tree <- function(newick.str=newick.medium,
col.edge  ='darkblue', lwd.edge =2,
col.elabel='darkblue',                cex.elabel=0.8, font.elabel=3,
col.arrow ='red',      lwd.arrow=1.5, cex.arrow =0.9, font.arrow =4,
col.clade ='black',    lwd.clade=1,   cex.clade =1.0, font.clade =3,
col.legbox='beige',                   cex.legend=0.8,
col.tip   ='darkblue',                                font.tip   =4,
plusx=FALSE, pltdebug=FALSE, total.snps=consistent.count[2],
straight.arrow=FALSE){
####
#
# ADJUST NEWICK & GET LENGTHS, COORDINATES
#
newick.str.noout <- sub('outgroup','_',newick.str) # Hide outgroup ('_' prints as blank)
the.tree <- read.tree(text=newick.str.noout)
## nasty hack: ape's newick parser seems to be confused by commas, () in tip labels, so
## newickize replaced them by '*<>'; before plotting, I want to convert them back, and hope
## this doesn't break anything else...  And if a revised version of ape changes the internal
## representation of a tree, this may need to be redone.
the.tree$tip.label <- newick.name.undo(the.tree$tip.label)
# extract branch lengths as char string of comma-separated numbers via pattern matching hack:
# lengths always preceded by colon
lengths.ch <- strsplit(paste(newick.str,':'),'[^0-9][^:]*:')[[1]]
# then convert to ints, dropping empty string at front
lengths.int <- scan(what=integer(),quiet=T,sep=',',text=lengths.ch[-1])
# then to data frame with named rows; a..g are terminal branches; others are internal.
# a..e match legend in plot; f/g = wales/italy.  lengths appear in postfix order of
# newick tree, and ape draws the 1st of them at the bottom of the plot.
lmed <- data.frame(lengths=lengths.int,
row.names=c('g','f','fg','e','d','de','c','b','bc','bcde','a','abcde','all','out'))
# extract counts needed for legend:
#leg.counts <- c(      61, 41,207, 61, 30, 1005,   18, 19) #by hand, medium chr1
leg.counts <- lmed[c('a','b','c','d','e','bcde','bc','de'),1]
discord <- total.snps - sum(lmed$lengths)
#tree.labels <- list( ## x,y,text; coords are all picked by eye
#   3000, 3.62, paste(lmed['all'  ,1], 'shared by 7', sep='\n'), # 7054
#   8900, 5.75, paste(lmed['abcde',1], 'by 5'       , sep='\n'), # 3912
#  12000, 1.50, paste(lmed['fg'   ,1], 'shared by 2', sep='\n'), # 9365
#  21000, 2.00, paste(lmed['f'    ,1], 'only\nin Wales'),        # 9652
#  21000, 1.00, paste(lmed['g'    ,1], 'only\nin Italy'),        # 8813
#  11500, 4.50, '*')
# automating x-placement, below; retain above for comparison...
tip <- integer(7)  # x coords of tree tips
tip[1] <-sum(lmed[c('all','fg','g'),1])
tip[2] <-sum(lmed[c('all','fg','f'),1])
tip[3] <-sum(lmed[c('all','abcde','bcde','de','e'),1])
tip[4] <-sum(lmed[c('all','abcde','bcde','de','d'),1])
tip[5] <-sum(lmed[c('all','abcde','bcde','bc','c'),1])
tip[6] <-sum(lmed[c('all','abcde','bcde','bc','b'),1])
tip[7] <-sum(lmed[c('all','abcde','a'),1])
inode <- integer(5) # x coords of (some) internal nodes
inode[1] <- 0                                    # root
inode[2] <- lmed['all',1]                        # lca of all
inode[3] <- sum(lmed[c('all','fg'),1])           # lca H-clade
inode[4] <- sum(lmed[c('all','abcde'),1])        # lca L-clade
inode[5] <- sum(lmed[c('all','abcde','bcde'),1]) # lca L-clade, nonGyre
tree.labels <- list( ## x,y,text; y coords partially picked by eye
sum(inode[c(1,2)])/2, 3.62, paste(lmed['all'  ,1], 'shared by 7', sep='\n'), # 7054
sum(inode[c(2,4)])/2, 5.75, paste(lmed['abcde',1], 'by 5'       , sep='\n'), # 3912
sum(inode[c(2,3)])/2, 1.50, paste(lmed['fg'   ,1], 'shared by 2', sep='\n'), # 9365
(inode[3]+tip[2])/2,  2.00, paste(lmed['f'    ,1], 'only\nin 1013'),         # 9652
(inode[3]+tip[1])/2,  1.00, paste(lmed['g'    ,1], 'only\nin 3367'),         # 8813
sum(inode[c(4,5)])/2, 4.35, '* ')
tree.labels <- list( ## x,y,text; y coords partially picked by eye
sum(inode[c(1,2)])/2, 3.62, paste(lmed['all'  ,1], 'in 7', sep='\n'), # 7054
sum(inode[c(2,4)])/2, 5.75, paste(lmed['abcde',1], 'in 5', sep='\n'), # 3912
sum(inode[c(2,3)])/2, 1.50, paste(lmed['fg'   ,1], 'in 2', sep='\n'), # 9365
(inode[3]+tip[2])/2,  2.00, paste(lmed['f'    ,1], 'only\nin 1013'),  # 9652
(inode[3]+tip[1])/2,  1.00, paste(lmed['g'    ,1], 'only\nin 3367'),  # 8813
sum(inode[c(4,5)])/2, 4.35, '* ')
####
#
# BOGUS PLOT
#
# a messy bit: need string widths to set xlim; but strwidth needs x-scale so must plot first.
# M plot completely invisible, overlay 2nd plot via par(new=F...) .
#
# PROVISIONALLY set x.lim here at about 30% wider than tree; fine tune it for the real plot
# based on strwidth(tip labels) below.
#
provisional.tree.x.lim <- 1.3 * max(tip) # <== PROVISIONAL plot width
plot(0,0, type='n', bty='n', xaxt='n', yaxt='n', xlab='', ylab='', xlim=c(0,provisional.tree.x.lim), ylim=c(0,7))
tiplabel.x <- integer(7)
for(i in 1:7){
# see warning above about internals of the.tree; labels have '_', printed as ' '.
tiplabel.x[i] <- tip[i]+strwidth(gsub('_',' ',the.tree$tip.label[i],fixed=T), font=font.tip)
}
# visually show tip coords & max x to debug placement issues
plt.debug <- function(tree.x.lim, tip, tiplabel.x, spx=NULL, spy=NULL){
if(pltdebug){ # F to hide/T to show debug
cat('Tip labels:', paste(the.tree$tip.label,sep='',collapse='/'), '\n')
axis(2) # useful only for placing labels
for(i in 1:7){
points(c(tip[i],tiplabel.x[i]),c(i,i)) # debug: do I have right tip coordinates?
}
lines(rep(tree.x.lim,2),c(0,7)) # where is right edge?
if(!is.null(spx)){
points(spx,spy) # show spline control points, for tweaking
}
}
}
plt.debug(provisional.tree.x.lim, tip, tiplabel.x)
label.end.H <- max(tiplabel.x[1:2])
label.end.L <- max(tiplabel.x[3:7])
clade.dx <- strwidth('x') # space between clade marker line and its label
xdel <- 3*clade.dx        # space between labeled clade tips and marker line
tree.x.lim <- 1.03*(max(tiplabel.x)+xdel)  # <== FINAL plot width
tree.y.lim <- 7
if(pltdebug){cat('Plot width hacking:', provisional.tree.x.lim, tree.x.lim, tree.x.lim/1.03/max(tip), clade.dx)}
par(new=T)  # I.e., NOT starting a new plot
####
#
# REAL PLOT
#
plot(the.tree,
x.lim = c(0, tree.x.lim),
y.lim = c(0, tree.y.lim),
font=font.tip, label.offset=100,             # bold-italic, nudged slightly right
tip.color=col.tip, edge.color=col.edge,
edge.width=lwd.edge,
edge.lty=c(1,1,1,1, 1 ,1,1,1,1,1,1,1,1,0)    # 5th is bottleneck edge; 14th is outgroup
)
lines(00+c(0,0),c(3.5,6),col='white',lwd=6)       # Hide vertical line to outgroup
axis(1, pos=0.25, at=seq(0,25,by=5)*10^round(log10(max(tip)/25)))
if(pltdebug){text(tip[1]+100, 1.0, 'Venice, Italy (3367)', adj=0, font=font.tip)}
####
#
# BOTTLENECK ANNOTATION
#
# spline/elipse control points (spy/y) & tweaks thereto (dx/y)
dx <- 0.01 * tree.x.lim
dy <- .04
spx <- c(7400, 7400, 9900, 10500) # by eye, chr1, for comparison
spx <- c(inode[2]+dx,inode[2]+dx,inode[4]-3*dx,inode[4]-dx)
spy <- c( 3.8,  3.9,  5.6-dy,   5.6-dy)
plt.debug(tree.x.lim, tip, tiplabel.x, spx, spy)
if(T){
#elipse version, defined by rect thru 2 middle pts of spx/y
spf<-function(x){
ifelse(x <= spx[2], spy[1],
ifelse(x >= spx[3], spy[4],
spy[2]+(spy[3]-spy[2])*sqrt(pmax(0,1-((x-spx[3])/(spx[3]-spx[2]))^2))))
}
} else {
# spline version
spf <- splinefun(spx,spy,method='hyman')
}
serx <- seq(spx[1],spx[length(spx)],length.out=50)
sery <- spf(serx)
tailx <- spx[1]
taily <- spy[1]
headx <- spx[4]
heady <- spy[4]
textx <- (headx+tailx)/2+(headx-tailx)*(-.01)
texty <- (heady+taily)/2+(heady-taily)*(-.10)
bottle.txt <- "inbreeding\nLoH / LoS"
if(!straight.arrow){
arrows(headx,heady,headx+tree.x.lim*1e-3,heady, length=.1,col=col.arrow,lwd=lwd.arrow)
lines(rev(serx), rev(sery), lty=c(5,1),col=col.arrow, lwd=lwd.arrow)
textangle <- 66
textadj <- c(0,0)
} else {
# Tweak positioning slightly; visualize a rectangle from 7-node to base of L-clade;
# center text, rotated, on diagonal towards L-clade; ditto the straight arrow.
llx <- inode[2] # the aforementioned rectangle
urx <- inode[4]
lly <- 3.62
ury <- 5.75
# rect(llx,lly,urx,ury) # show rect for debug
textx <- (llx+urx)/2    # center text
texty <- (lly+ury)/2
textangle <- atan(grconvertY(ury-lly,to='dev')/grconvertX(urx-llx,to='dev'))*360/(2*pi)
textadj <- c(0.50, 0.43)
alpha <- .78 # fraction along diag at which arrow begins
beta  <- .95 # ... and ends
arrows((1-alpha)*llx + alpha*urx,
(1-alpha)*lly + alpha*ury,
(1-beta)*llx  + beta*urx,
(1-beta)*lly  + beta*ury, length=.1,col=col.arrow,lwd=lwd.arrow,angle=25)
}
if(T){
text(textx, texty, bottle.txt, srt=textangle, font=font.arrow, cex=cex.arrow,
col=col.arrow, adj=textadj)
} else {
# experiment at wrapping text along curved path; unpretty, but retain for now, maybe revisit
bottlec <- strsplit(bottle,split=NULL)[[1]]
for(i in 1:length(bottlec)){
text(xser[i],yser[i],bottlec[i], srt=65, font=4, cex=.7, col=col.arrow)
}
}
####
#
# CLADE ANNOTATION
#
clade.L.x <- label.end.L + xdel
clade.H.x <- label.end.H + xdel
dy <-.33
lines(rep(clade.L.x,2),c(3-dy,7+dy),lwd=lwd.clade,col=col.clade)
lines(rep(clade.H.x,2),c(1-dy,2+dy),lwd=lwd.clade,col=col.clade)
text(clade.L.x+clade.dx,5.0,'L-clade',srt=90,font=font.clade,cex=cex.clade,col=col.clade)
text(clade.H.x+clade.dx,1.5,'H-clade',srt=90,font=font.clade,cex=cex.clade,col=col.clade)
####
#
# LEGEND
#
# parameter plusx controls whether we try to annotate b/c (+) and d/e (x) sharing in tree; I think
# it looks cluttered, rather than adding clarity, so I vote no, but code is here, in case.  "Logic,"
# if any, for my symbol choice is that + overlaid on x looks like the * at the next level; this
# analogy is more visible if we use pch 3/4/8 rather than Courier or Helvetica chars, but probably
# should use same in both tree & legend, which will take a modicum of additional work.
legend.text <- c('a: only in 1014  ',
'b: only in 1335  ',
'c: only in 1015  ',
'd: only in 1012  ',
'e: only in 1007  ',
'*: shared by bcde',
paste(ifelse(plusx,'+:','  '),'shared by b/c '),
paste(ifelse(plusx,'x:','  '),'shared by d/e ')
)
legend.text <- c('a: only in 1014 ',
'b: only in 1335 ',
'c: only in 1015 ',
'd: only in 1012 ',
'e: only in 1007 ',
'*: in bcde      ',
paste(ifelse(plusx,'+:','  '),'in bc        '),
paste(ifelse(plusx,'x:','  '),'in de        '),
'Discordant SNPs '
)
legend.text <- paste(legend.text,format(c(leg.counts,discord),width=4),sep=' - ')
legend.text <- paste(legend.text,' ') # add a little more right margin in box
opar <- par(family='mono',cex=cex.legend)
legend('topright', legend=legend.text, cex=cex.legend, inset=c(0.05,0), bg=col.legbox, box.col=col.legbox)
par(opar)
if(plusx){
points(tree.labels[[16]],tree.labels[[17]]+.14,pch=8,col=col.elabel)
points(tree.labels[[16]]+200,tree.labels[[17]]+1,pch=3,col=col.elabel)
points(tree.labels[[16]]+200,tree.labels[[17]]-1,pch=4,col=col.elabel)
}
####
#
# EDGE LENGTHS
#
for(i in seq(1,length(tree.labels)-ifelse(plusx,5,2),by=3)){
if(F){ # T for \n in edge labels; F to remove (except "by 5")
text(tree.labels[[i]], tree.labels[[i+1]], tree.labels[[i+2]])
} else {
# points(tree.labels[[i]], tree.labels[[i+1]], pch=3,col='green') # for debugging
text(tree.labels[[i]], tree.labels[[i+1]], sub('\n([^z])',' \\1', tree.labels[[i+2]]),
pos=3, offset=.4, font=font.elabel, col=col.elabel,cex=cex.elabel)
}
}
}
pdf(paperfig.path, width=8,height=5,onefile=TRUE,family='Helvetica',fonts='Courier',pointsize=10)
show.tree(newick.medium, total.snps=consistent.count[2], pltdebug=F,straight.arrow = T)
dev.off()
require
search()
library()
library
library(compactr)
print(library(compactr))
foo<-function(){print(library(compactr))};foo()
search()
.libPaths
.libPaths()
find.package('compactr')
find.package('compactr',lib.loc=.libPaths())
print(library(R.utils))
install.packages("R.utils")
print(library(R.utils))
installed.packages
installed.packages()
.packages()
search()
isPackageLoaded(compactr)
isPackageLoaded('compactr')
isPackageLoaded('compactr')
isPackageLoaded('compactrx')
isPackageInstalled('compactrx')
isPackageInstalled('compactr')
