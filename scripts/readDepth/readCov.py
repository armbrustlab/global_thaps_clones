#1/usr/bin/env python2.7

#Need to write a shell script to take in the various .mpu files
#and write out the tables to read into R. Should work in the
#pipeline which starts from the .BAM files

#mpufiles = ['tp1007.mpu','tp1012.mpu','tp1013.mpu','tp1014.mpu',
#'tp1015.mpu','tp3369.mpu','tp1335.mpu']
#snpfiles = ['tp1007.pos.tab','tp1012.pos.tab','tp1013.pos.tab',
#'tp1014.pos.tab','tp1015.pos.tab','tp3369.pos.tab', 'tp1335.pos.tab']

import string
import re
import collections
import sys

def file_len(fn):
    with open(fn) as f:
        for i, l in enumerate(f):
            pass
    return i + 1

##Load the SNP tables generated by CB
#snp = 'tp3369.pos.tab'
#fds = open(snp, 'r')
#snps = []
#for line in fds:
#    snps.append(line.split('\t')[2])
#fds.close()

c = collections.Counter
qualThresh = 50
fname = 'Tp3369Ch1-Q30.mpu'
#fname = 'test2.mpu'
column = 6
fd = open(fname, 'r')
data0 = list() #this will grab the first 4 columns (Chrome, Position, Reference NT, Coverage)
data1 = list() #this will grab a string that encodes each nt...string length == coverage
data2 = list() #this will grab a string that encodes the qual for each nt
tst = list()   #just a test list...will be deleted later.
countList = list()
combList = []

##Parse each of the columns in the mpileup (*.mpu) generated file
#totnum = file_len(fname)
#lnum = 0
for line in fd:
    tokens = line.split('\t')
    data0.append(tokens[0:4])
    data1.append(tokens[column-2])
    data2.append([ord(x) - 33 for x in tokens[column-1][0:(len(tokens[column-1])-1)]])
#    if lnum == (totnum-1):
#        data2.append([ord(x) - 33 for x in tokens[column-1][0:(len(tokens[column-1]))]])
#    else:
#        data2.append([ord(x) - 33 for x in tokens[column-1][0:(len(tokens[column-1])-1)]])
#    lnum = lnum+1

#for i, line in enumerate(fd):
#    if i > desStart and i< desEnd:
#        print(line)
#        tokens = line.split('\t')
#        data0.append(tokens[0:3])
#        data1.append(tokens[column-2])

caret = re.compile('\^') #We want not to count "^" characters in data1
modCaret = list() #this will be a new string where we mod out the "^" from the old string in data1

#######################################
#data2 = data1[desStart:desEnd]
#data3 = data0[desStart:desEnd]
########################################

for string in data1: ##build a list of double strings...NT and it's associated qual
    length = len(string)
    string = str.lower(string)
    cList = list(caret.finditer(string)) ##this should be a list of all the positions where we have a "^"
    if(len(cList)==0):
        modCaret.append(string)
    else:
        newstring = ""
        start = 0
        stop = 0
        for i in range(len(cList)):
            stop = cList[i].start()
            newstring += string[start:stop]
            start = cList[i].end()+1 ##this should remove the "^" and position immediately after
        #if start > length, do nothing
        if start == length:
        #if you only want the last element, you need to go to len(string)-1
            newstring += string[start - 1]
        elif start < length:
        #crazy syntax if you use ':' you need to go to len(string)
            newstring += string[start:len(string)]
        modCaret.append(newstring)


###I need to get rid of all extraneous characters like the "$" and "*"...

dsandstar = re.compile('[$]')
modDSstar = list()

for string in modCaret:
    length = len(string)
    dssList = list(dsandstar.finditer(string))
    if(len(dssList) == 0):
        modDSstar.append(string)
    else:
        newstring = ""
        start = 0
        stop = 0
        for i in range(len(dssList)):
            stop = dssList[i].start()
            newstring += string[start:stop]
            start = dssList[i].end()
            if start > length:
                break
        if start == length:
            print("")
        elif start < length:
            newstring += string[start:len(string)]
        modDSstar.append(newstring)


plusMinus = re.compile('[-+]') ##this indexes relative indels in the string. we need to find these positions
                               ##immediate after we have an integer telling us how big is the indel then the actually NTs
                               ##+2aa means insertion of two A's
jj = 0
for qstring in zip(modDSstar, data2):
    string = qstring[0]
    qual = qstring[1]
    length = len(string)
    pmList = list(plusMinus.finditer(string)) ##positions of "+-" in the string w/o "^"
    pmDeets = plusMinus.findall(string)  ##need to look up...but it should give the details of plusminus
    if(len(pmList)==0):
        if(len(string) == len(qual)):
            qstring = [a[0] for a in zip(string, qual) if a[1] > qualThresh]
            cnt =c(qstring)
        #cnt = sorted(cnt.items())
        #outputList.append(cnt)
            countList.append([str(cnt['a']), str(cnt['g']), str(cnt['c']), str(cnt['t']), str(cnt['n']), str(cnt['.']+cnt[',']+cnt['*'])])
            jj = jj+1
        else:
            print("Number of bases does not equal the number of qualities")
            print(jj)
            sys.exit()
    else:
        newstring = ""
        start = 0
        stop = 0
        for i in range(len(pmList)):
            stop = pmList[i].start()
            newstring += string[start:stop]

            ###this presumes that indels are only single digits. the if statement takes care of this
            if(string[pmList[i].end()+1].isdigit()):
                start = pmList[i].end() + int(string[pmList[i].end()]+string[pmList[i].end()+1]) + 2
            else:
                start = pmList[i].end() + int(string[pmList[i].end()]) + 1

        #if the indel is at the end
        #if start == length:


        #if start == length-1:
        #if you only want the last element, you need to go to len(string)-1
        #    newstring += string[start]
        if start < length:
        #crazy syntax if you use ':' you need to go to len(string)
            #newstring += string[start:len(string)]
            newstring += string[start:]

        if(len(newstring) == len(qual)):
            qnewstring = [a[0] for a in zip(newstring, qual) if a[1] > qualThresh]
            cnt = c(qnewstring)
        #cnt = sorted(cnt.items())
        #outputList.append(cnt)
            countList.append([str(cnt['a']), str(cnt['g']), str(cnt['c']), str(cnt['t']), str(cnt['n']), str(cnt['.']+cnt[',']+cnt['*'])])
            jj = jj+1
        else:
            print("Number of bases does not equal the number of qualities")
            print(jj)
            sys.exit()

#if(len(data0) != len(snps)):
#    print "Chris's table does not match the table generated here"

#if(len(data0) != len(countList)):
#if(len(data3) != len(countList)):
#    print "There is an error: the number of references do not match the number of rows of reads"

#else:
#    for i in range(len(data0)):
#        combList.append(data0[i]+countList[i]+snps[i])
#    for i in range(len(data3)):
#        combList.append(data3[i]+countList[i])
        #print(combList, sep='\t')
#combList.insert(0, ['Chr', 'Pos', 'Ref', 'a', 'g', 'c', 't', 'n', '.match', 'SNP'])

for i in range(len(data0)):
    combList.append(data0[i]+countList[i])

combList.insert(0, ['Chr', 'Pos', 'Ref', 'Cov', 'a', 'g', 'c', 't', 'n', '.match' ])

with open('tp3369-ch1-q50.tab', 'w') as file:
    file.writelines('\t'.join(i) + '\n' for i in combList)

fd.close()


